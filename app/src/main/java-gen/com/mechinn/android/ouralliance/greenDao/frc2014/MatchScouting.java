package com.mechinn.android.ouralliance.greenDao.frc2014;

import com.mechinn.android.ouralliance.greenDao.frc2014.dao.DaoSession;
import de.greenrobot.dao.DaoException;

import com.mechinn.android.ouralliance.greenDao.frc2014.dao.MatchDao;
import com.mechinn.android.ouralliance.greenDao.frc2014.dao.MatchScoutingDao;
import com.mechinn.android.ouralliance.greenDao.frc2014.dao.TeamScoutingDao;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS

// KEEP INCLUDES - put your custom includes here
// KEEP INCLUDES END
/**
 * Entity mapped to table MATCH_SCOUTING.
 */
public class MatchScouting {

    private Long id;
    private java.util.Date modified;
    private Long match;
    private Long team;
    private Boolean alliance;
    private Integer position;
    private String notes;
    private Integer hotShots;
    private Integer shotsMade;
    private Integer shotsMissed;
    private Double moveForward;
    private Boolean shooter;
    private Boolean catcher;
    private Boolean passer;
    private Double driveTrainRating;
    private Double ballAccuracyRating;
    private Boolean ground;
    private Boolean overTruss;
    private Boolean low;
    private Boolean high;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient MatchScoutingDao myDao;

    private Match match;
    private Long match__resolvedKey;

    private TeamScouting teamScouting;
    private Long teamScouting__resolvedKey;


    // KEEP FIELDS - put your custom fields here
    // KEEP FIELDS END

    public MatchScouting() {
    }

    public MatchScouting(Long id) {
        this.id = id;
    }

    public MatchScouting(Long id, java.util.Date modified, Long match, Long team, Boolean alliance, Integer position, String notes, Integer hotShots, Integer shotsMade, Integer shotsMissed, Double moveForward, Boolean shooter, Boolean catcher, Boolean passer, Double driveTrainRating, Double ballAccuracyRating, Boolean ground, Boolean overTruss, Boolean low, Boolean high) {
        this.id = id;
        this.modified = modified;
        this.match = match;
        this.team = team;
        this.alliance = alliance;
        this.position = position;
        this.notes = notes;
        this.hotShots = hotShots;
        this.shotsMade = shotsMade;
        this.shotsMissed = shotsMissed;
        this.moveForward = moveForward;
        this.shooter = shooter;
        this.catcher = catcher;
        this.passer = passer;
        this.driveTrainRating = driveTrainRating;
        this.ballAccuracyRating = ballAccuracyRating;
        this.ground = ground;
        this.overTruss = overTruss;
        this.low = low;
        this.high = high;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getMatchScoutingDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public java.util.Date getModified() {
        return modified;
    }

    public void setModified(java.util.Date modified) {
        this.modified = modified;
    }

    public Long getMatch() {
        return match;
    }

    public void setMatch(Long match) {
        this.match = match;
    }

    public Long getTeam() {
        return team;
    }

    public void setTeam(Long team) {
        this.team = team;
    }

    public Boolean getAlliance() {
        return alliance;
    }

    public void setAlliance(Boolean alliance) {
        this.alliance = alliance;
    }

    public Integer getPosition() {
        return position;
    }

    public void setPosition(Integer position) {
        this.position = position;
    }

    public String getNotes() {
        return notes;
    }

    public void setNotes(String notes) {
        this.notes = notes;
    }

    public Integer getHotShots() {
        return hotShots;
    }

    public void setHotShots(Integer hotShots) {
        this.hotShots = hotShots;
    }

    public Integer getShotsMade() {
        return shotsMade;
    }

    public void setShotsMade(Integer shotsMade) {
        this.shotsMade = shotsMade;
    }

    public Integer getShotsMissed() {
        return shotsMissed;
    }

    public void setShotsMissed(Integer shotsMissed) {
        this.shotsMissed = shotsMissed;
    }

    public Double getMoveForward() {
        return moveForward;
    }

    public void setMoveForward(Double moveForward) {
        this.moveForward = moveForward;
    }

    public Boolean getShooter() {
        return shooter;
    }

    public void setShooter(Boolean shooter) {
        this.shooter = shooter;
    }

    public Boolean getCatcher() {
        return catcher;
    }

    public void setCatcher(Boolean catcher) {
        this.catcher = catcher;
    }

    public Boolean getPasser() {
        return passer;
    }

    public void setPasser(Boolean passer) {
        this.passer = passer;
    }

    public Double getDriveTrainRating() {
        return driveTrainRating;
    }

    public void setDriveTrainRating(Double driveTrainRating) {
        this.driveTrainRating = driveTrainRating;
    }

    public Double getBallAccuracyRating() {
        return ballAccuracyRating;
    }

    public void setBallAccuracyRating(Double ballAccuracyRating) {
        this.ballAccuracyRating = ballAccuracyRating;
    }

    public Boolean getGround() {
        return ground;
    }

    public void setGround(Boolean ground) {
        this.ground = ground;
    }

    public Boolean getOverTruss() {
        return overTruss;
    }

    public void setOverTruss(Boolean overTruss) {
        this.overTruss = overTruss;
    }

    public Boolean getLow() {
        return low;
    }

    public void setLow(Boolean low) {
        this.low = low;
    }

    public Boolean getHigh() {
        return high;
    }

    public void setHigh(Boolean high) {
        this.high = high;
    }

    /** To-one relationship, resolved on first access. */
    public Match getMatch() {
        Long __key = this.match;
        if (match__resolvedKey == null || !match__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MatchDao targetDao = daoSession.getMatchDao();
            Match matchNew = targetDao.load(__key);
            synchronized (this) {
                match = matchNew;
            	match__resolvedKey = __key;
            }
        }
        return match;
    }

    public void setMatch(Match match) {
        synchronized (this) {
            this.match = match;
            match = match == null ? null : match.getId();
            match__resolvedKey = match;
        }
    }

    /** To-one relationship, resolved on first access. */
    public TeamScouting getTeamScouting() {
        Long __key = this.team;
        if (teamScouting__resolvedKey == null || !teamScouting__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            TeamScoutingDao targetDao = daoSession.getTeamScoutingDao();
            TeamScouting teamScoutingNew = targetDao.load(__key);
            synchronized (this) {
                teamScouting = teamScoutingNew;
            	teamScouting__resolvedKey = __key;
            }
        }
        return teamScouting;
    }

    public void setTeamScouting(TeamScouting teamScouting) {
        synchronized (this) {
            this.teamScouting = teamScouting;
            team = teamScouting == null ? null : teamScouting.getId();
            teamScouting__resolvedKey = team;
        }
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

    // KEEP METHODS - put your custom methods here
    // KEEP METHODS END

}
